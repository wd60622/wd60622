{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello My name is Will Dean. My background is in Statistics and have been working as a Data Scientist the last 4 years in the transportation and real estate industries. I enjoy working with geographical data. Most likely because it helps me forget about my Fernweh . I love to travel and figure out how the world works while talking to people in the process. I am currently interested in exploring different Bayesian models, specifically with the library PyMC . I find the software fun to use and very helpful for the problems I like to solve. Some of my other favorite python software recently is: PyYAML rich fastapi / typer (big fan of all the creator's work) geopandas As of late, I have been exploring python code design techniques to create easy-to-use APIs that can be easily extended. This YouTube Channel has been an inspiration for me. I love to learn and collaborate so feel free to connect with me ! I've been looking into freelancing and have some options posted here as well.","title":"Welcome"},{"location":"#hello","text":"My name is Will Dean. My background is in Statistics and have been working as a Data Scientist the last 4 years in the transportation and real estate industries. I enjoy working with geographical data. Most likely because it helps me forget about my Fernweh . I love to travel and figure out how the world works while talking to people in the process. I am currently interested in exploring different Bayesian models, specifically with the library PyMC . I find the software fun to use and very helpful for the problems I like to solve. Some of my other favorite python software recently is: PyYAML rich fastapi / typer (big fan of all the creator's work) geopandas As of late, I have been exploring python code design techniques to create easy-to-use APIs that can be easily extended. This YouTube Channel has been an inspiration for me. I love to learn and collaborate so feel free to connect with me ! I've been looking into freelancing and have some options posted here as well.","title":"Hello"},{"location":"tags/","text":"Tags Config Files Pydantic for Configs Python My Favorite Python builtin: pathlib Pydantic for Configs Standard Library My Favorite Python builtin: pathlib","title":"Tags"},{"location":"tags/#tags","text":"","title":"Tags"},{"location":"tags/#config-files","text":"Pydantic for Configs","title":"Config Files"},{"location":"tags/#python","text":"My Favorite Python builtin: pathlib Pydantic for Configs","title":"Python"},{"location":"tags/#standard-library","text":"My Favorite Python builtin: pathlib","title":"Standard Library"},{"location":"blog/","text":"Blog Posts Here are some things that I've found interesting","title":"Blog Posts"},{"location":"blog/#blog-posts","text":"Here are some things that I've found interesting","title":"Blog Posts"},{"location":"blog/posts/2022/pathlib/","tags":["Python","Standard Library"],"text":"My Favorite Python builtin: pathlib When working with python and data, file names quickly become a pain for many reasons. Firstly, files quickly add up. This could be from raw data, created processed data, config files, results including models and vizualizations. Using the strings can work, but this leads to working with many of the functions from the os and os.path modules. import os from os.path import join CURRENT_DIR : str = os . getcwd () file_name : str = \"my-data.csv\" data_file = join ( CURRENT_DIR , file_name ) print ( f \"The file { data_file } exists: { os . path . isfile ( data_file ) } \" ) Quick Start Using a data folder I often have a DATA_DIR constent for many of my projects setting up a folder data off the root of my project. my_module data my_module/utils.py from pathlib import Path DATA_DIR = Path ( __file__ ) if not DATA_DIR . exists (): DATA_DIR . mkdir () I often extend this to include other folders I will likely have based on a project. This might be a folder data/raw , data/results , or even a configs dir. Working with S3 locations I learned about this project while working with S3 paths on AWS. I haven't personally used but I think it looks promising and would provide a similar experience as the pathlib module. https://github.com/liormizr/s3path","title":"My Favorite Python builtin: pathlib"},{"location":"blog/posts/2022/pathlib/#my-favorite-python-builtin-pathlib","text":"When working with python and data, file names quickly become a pain for many reasons. Firstly, files quickly add up. This could be from raw data, created processed data, config files, results including models and vizualizations. Using the strings can work, but this leads to working with many of the functions from the os and os.path modules. import os from os.path import join CURRENT_DIR : str = os . getcwd () file_name : str = \"my-data.csv\" data_file = join ( CURRENT_DIR , file_name ) print ( f \"The file { data_file } exists: { os . path . isfile ( data_file ) } \" )","title":"My Favorite Python builtin: pathlib"},{"location":"blog/posts/2022/pathlib/#quick-start","text":"","title":"Quick Start"},{"location":"blog/posts/2022/pathlib/#using-a-data-folder","text":"I often have a DATA_DIR constent for many of my projects setting up a folder data off the root of my project. my_module data my_module/utils.py from pathlib import Path DATA_DIR = Path ( __file__ ) if not DATA_DIR . exists (): DATA_DIR . mkdir () I often extend this to include other folders I will likely have based on a project. This might be a folder data/raw , data/results , or even a configs dir.","title":"Using a data folder"},{"location":"blog/posts/2022/pathlib/#working-with-s3-locations","text":"I learned about this project while working with S3 paths on AWS. I haven't personally used but I think it looks promising and would provide a similar experience as the pathlib module. https://github.com/liormizr/s3path","title":"Working with S3 locations"},{"location":"blog/posts/2022/pydantic-configs/","tags":["Python","Config Files"],"text":"Using PyDantic for Configs I discovered the pydantic library when I first started using Typer and FastAPI and quickly found the library very useful for other reasons. One usecase I've found very helpful is when making config files for python scripts. There is clear benefit to using configs when writing python code. i.e. you can change variables without having to edit the python file itself. But by also using pydantic you get the additional benefits provided from the library. Clearly Define the Structure of the Config When working with configs, I often find it confusing to what all the possible supported settings are. However, if you define a pydantic basemodel, you see clear instructions for what you are working with. For instance, a project which from pydantic import BaseModel from pathlib import Path from typing import Dict class Config ( BaseModel ): # Input input_location : Path # Result location and file name results_dir : Path results_file_name : str plotting_kwargs : Dict config.yaml input_location : ./data/input_data.csv results_dir : . results_file_name : my_first_run.png plotting_kwargs : alpha : 0.5 Adding Hierarchy If the config starts to get too long, then I've found splitting up into different sections to be very helpful. This can be sections for inputs, output, related setting, etc. input : file : some-input-file.csv output : base_dir : some-directory-to-save result_name : some-file-name.png Each one of the sections would be its own class in the defined pydantic model. class InputSetting ( BaseModel ): file : Path class OutputSetting ( BaseModel ): base_dir : Path results_name : str class Config ( BaseModel ): \"\"\"Class version of the full config file\"\"\" input : InputSettings output : OutputSettings Limiting Options If you want to limit options, an enum.Enum type can be used to enforce only a set number of choices. This provides some checking at config parsing time which can give you some quick feedback. from enum import Enum class Difficulties ( Enum ): EASY : str = \"easy\" MEDIUM : str = \"medium\" HARD : str = \"hard\" class Config ( BaseModel ): difficulty : Difficulties Also just take advantage of all the added validation that pydantic provides. If you are used to using dataclasses too, the dataclasses submodule can be very helpful in order to add some additional checks on the configs at runtime. from pydantic.dataclasses import dataclass @dataclass class ResultSettings : results_dir : Path file_name : str override : bool = False def __post_init__ ( self ) -> None : if not self . results_dir . exists (): self . results_dir . mkdir () save_location = self . results_dir / self . file_name if save_location . exists () and not override : msg = f \"The results already exists. Not running { save_location } \" raise ValueError ( msg ) Class Implementation I often add a lightweight class implementation when working with YAML configs. The goal here is to add an additional method to the pydantic BaseModel in order to easily load different config files. yaml_base_model.py from pydantic import BaseModel import yaml from pathlib import Path class YamlBaseModel ( BaseModel ) @classmethod def from_yaml ( cls , file : str | Path ) -> YamlBaseModel : file = Path ( file ) with open ( file , \"r\" ) as f : data = yaml . safe_load ( f ) return cls . parse_obj ( data ) This allows for easy construction of a con Find the gist of this here with an additional example. Conclusion Overall, I've found defining configs with pydantic in mind very useful","title":"Pydantic for Configs"},{"location":"blog/posts/2022/pydantic-configs/#using-pydantic-for-configs","text":"I discovered the pydantic library when I first started using Typer and FastAPI and quickly found the library very useful for other reasons. One usecase I've found very helpful is when making config files for python scripts. There is clear benefit to using configs when writing python code. i.e. you can change variables without having to edit the python file itself. But by also using pydantic you get the additional benefits provided from the library.","title":"Using PyDantic for Configs"},{"location":"blog/posts/2022/pydantic-configs/#clearly-define-the-structure-of-the-config","text":"When working with configs, I often find it confusing to what all the possible supported settings are. However, if you define a pydantic basemodel, you see clear instructions for what you are working with. For instance, a project which from pydantic import BaseModel from pathlib import Path from typing import Dict class Config ( BaseModel ): # Input input_location : Path # Result location and file name results_dir : Path results_file_name : str plotting_kwargs : Dict config.yaml input_location : ./data/input_data.csv results_dir : . results_file_name : my_first_run.png plotting_kwargs : alpha : 0.5","title":"Clearly Define the Structure of the Config"},{"location":"blog/posts/2022/pydantic-configs/#adding-hierarchy","text":"If the config starts to get too long, then I've found splitting up into different sections to be very helpful. This can be sections for inputs, output, related setting, etc. input : file : some-input-file.csv output : base_dir : some-directory-to-save result_name : some-file-name.png Each one of the sections would be its own class in the defined pydantic model. class InputSetting ( BaseModel ): file : Path class OutputSetting ( BaseModel ): base_dir : Path results_name : str class Config ( BaseModel ): \"\"\"Class version of the full config file\"\"\" input : InputSettings output : OutputSettings","title":"Adding Hierarchy"},{"location":"blog/posts/2022/pydantic-configs/#limiting-options","text":"If you want to limit options, an enum.Enum type can be used to enforce only a set number of choices. This provides some checking at config parsing time which can give you some quick feedback. from enum import Enum class Difficulties ( Enum ): EASY : str = \"easy\" MEDIUM : str = \"medium\" HARD : str = \"hard\" class Config ( BaseModel ): difficulty : Difficulties Also just take advantage of all the added validation that pydantic provides. If you are used to using dataclasses too, the dataclasses submodule can be very helpful in order to add some additional checks on the configs at runtime. from pydantic.dataclasses import dataclass @dataclass class ResultSettings : results_dir : Path file_name : str override : bool = False def __post_init__ ( self ) -> None : if not self . results_dir . exists (): self . results_dir . mkdir () save_location = self . results_dir / self . file_name if save_location . exists () and not override : msg = f \"The results already exists. Not running { save_location } \" raise ValueError ( msg )","title":"Limiting Options"},{"location":"blog/posts/2022/pydantic-configs/#class-implementation","text":"I often add a lightweight class implementation when working with YAML configs. The goal here is to add an additional method to the pydantic BaseModel in order to easily load different config files. yaml_base_model.py from pydantic import BaseModel import yaml from pathlib import Path class YamlBaseModel ( BaseModel ) @classmethod def from_yaml ( cls , file : str | Path ) -> YamlBaseModel : file = Path ( file ) with open ( file , \"r\" ) as f : data = yaml . safe_load ( f ) return cls . parse_obj ( data ) This allows for easy construction of a con Find the gist of this here with an additional example.","title":"Class Implementation"},{"location":"blog/posts/2022/pydantic-configs/#conclusion","text":"Overall, I've found defining configs with pydantic in mind very useful","title":"Conclusion"},{"location":"blog/posts/2022/site-setup/","text":"Creating this Site This website was created using MkDocs , surrounding python libraries, and is served with GitHub pages. MkDocs The MkDocs library provides some easy to use","title":"Creating this Site"},{"location":"blog/posts/2022/site-setup/#creating-this-site","text":"This website was created using MkDocs , surrounding python libraries, and is served with GitHub pages.","title":"Creating this Site"},{"location":"blog/posts/2022/site-setup/#mkdocs","text":"The MkDocs library provides some easy to use","title":"MkDocs"},{"location":"resources/","text":"Favorite Resources Tools Notion I started using Notion for organizing my life. I find it is a great tool for personal projects, journaling, and all things above. There is so many customization options to it out of the box and the features keep on improving. It is also very awesome that it can be used on all platforms. YouTube ArjanCodes This guy puts out some high quality content for python programming. I've really enjoyed all of his material and he posts very consistently. I've found my coding style to be heavily influenced by him and I have found many resources because of him.","title":"Favorite Resources"},{"location":"resources/#favorite-resources","text":"","title":"Favorite Resources"},{"location":"resources/#tools","text":"","title":"Tools"},{"location":"resources/#notion","text":"I started using Notion for organizing my life. I find it is a great tool for personal projects, journaling, and all things above. There is so many customization options to it out of the box and the features keep on improving. It is also very awesome that it can be used on all platforms.","title":"Notion"},{"location":"resources/#youtube","text":"","title":"YouTube"},{"location":"resources/#arjancodes","text":"This guy puts out some high quality content for python programming. I've really enjoyed all of his material and he posts very consistently. I've found my coding style to be heavily influenced by him and I have found many resources because of him.","title":"ArjanCodes"},{"location":"tags/","text":"Tags Config Files Pydantic for Configs Python My Favorite Python builtin: pathlib Pydantic for Configs Standard Library My Favorite Python builtin: pathlib","title":"Tags"},{"location":"tags/#tags","text":"","title":"Tags"},{"location":"tags/#config-files","text":"Pydantic for Configs","title":"Config Files"},{"location":"tags/#python","text":"My Favorite Python builtin: pathlib Pydantic for Configs","title":"Python"},{"location":"tags/#standard-library","text":"My Favorite Python builtin: pathlib","title":"Standard Library"}]}